package parsleyj.NetSecLab.lab1.prngcipher;

import parsleyj.NetSecLab.util.HexStrings;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Scanner;

/**
 * Using a byte sequence input as seed, generates a pseudo-random sequence of bytes.
 * This sequence is used as key for a symmetric "xor" cipher.
 * <br>
 * <br>
 *     Original exercise text:
 * <p>
 *     1.1. Create a simple stream cipher based on a PRNG (pseudo-random number generator). For example you can use the
 *     SHA1PRNG provided by class SecureRandom of java, and use the seed as secret. Write a simple program that encrypt
 *     a text and than decrypt it.
 * </p>
 * <br>
 * <p>
 * Created on 28/02/2019.
 * </p>
 * @author Giuseppe Petrosino - giuseppe.petrosino@studenti.unipr.it
 */
@SuppressWarnings("WeakerAccess")
public class PRNGStreamCipher {

    private byte[] key;

    /**
     * Initializes the cipher with a "key", which will be later used as seed to generate a pseudo-random sequence in
     * the encrypt and decrypt operations
     *
     * @param key the key
     */
    public PRNGStreamCipher(byte[] key) {
        this.key = key;
    }

    /**
     * Encrypts the given input byte sequence, using a random byte sequence generated by an instance of SecureRandom
     * (initialized with the SHA1PRNG algorithm) as key.
     * The seed of the SecureRandom instance is the byte sequence in the field {@link #key}.
     *
     * @param input the byte sequence
     * @return the encrypted byte sequence
     * @throws NoSuchAlgorithmException if the SHA1PRNG algorithm is not available in the environment
     */
    public byte[] encrypt(byte[] input) throws NoSuchAlgorithmException {
        SecureRandom secureRandom;

        secureRandom = SecureRandom.getInstance("SHA1PRNG");
        secureRandom.setSeed(key);

        byte[] random = new byte[input.length];
        secureRandom.nextBytes(random);
        byte[] encriptedBytes = new byte[input.length];
        for (int i = 0; i < input.length; i++) {
            byte b1 = input[i];
            byte b2 = random[i];

            encriptedBytes[i] = (byte) (b1 ^ b2);
        }
        return encriptedBytes;
    }


    /**
     * Decrypts the given input byte sequence by calling internally the {@link #encrypt(byte[])} method. This is a valid
     * design strategy due to the commutative property of the bit-wise xor operation (encryption and decryption
     * operations are performed by the same algorithm).
     *
     * @param input the encrypted byte sequence
     * @return the decrypted byte sequence
     * @throws NoSuchAlgorithmException if the SHA1PRNG algorithm is not available in the environment
     */
    public byte[] decrypt(byte[] input) throws NoSuchAlgorithmException {
        return encrypt(input);
    }


    /**
     * An example entry point main method to test the cipher.
     *
     * @param argv COMMAND LINE ARGUMENTS IGNORED
     * @throws NoSuchAlgorithmException if the SHA1PRNG algorithm is not available in the environment
     */
    public static void main(String[] argv) throws NoSuchAlgorithmException {

        Scanner sc = new Scanner(System.in);

        System.out.println("Key = ?");
        String key = sc.nextLine();

        PRNGStreamCipher prngSC = new PRNGStreamCipher(key.getBytes());

        System.out.println("Text = ?");
        String text = sc.nextLine();

        System.out.println();

        System.out.println("Text in hex:");
        System.out.println(HexStrings.toHexString(text.getBytes()));

        byte[] encrypted = prngSC.encrypt(text.getBytes());
        System.out.println("Encrypted (hex):");
        System.out.println(HexStrings.toHexString(encrypted));

        byte[] decrypted = prngSC.decrypt(encrypted);
        System.out.println("Decrypted (hex):");
        System.out.println(HexStrings.toHexString(decrypted));

        System.out.println("Decrypted text:");
        System.out.println(new String(decrypted));
    }
}
